=========================
Protein-DNA with MELD
=========================

Intro
===========================

In this tutorial we are going to prepare a setup script and other necessary files required for a Protein-DNA simulation. It is recommended that you review "getting started" before this one. The ideal goal of this part is to sample many binding/unbinfding events so that the protein has enough chances of exploring and finding the right binding pose. For sake of simplicity, I'm using 1azp_, a small protein-DNA complex from PDB. Here's a list of files needed for this tutorial (all of them are in "example" folder):

.. _1azp: https://www.rcsb.org/structure/1AZP

* DNA-sequence.dat
* hbondsDNA.dat
* secondary-structure.dat
* protein-contacts.dat
* starting-structure.pdb
* restraints.py
* setupMELD.py

DNA-sequence.dat
----------------------------
This is a simple dat file with the sequence of the first DNA strand in FASTA format without the header:

``GCGATCGC``

DNA-hbonds.dat
----------------------------
This file will be generated by setupMELD.py automatically and it includes hydrogen bond contacts between DNA pairs.
Here's the first five lines of the file:
::

  1 N2 16 O2 3.0
  
  1 N1 16 N3 3.0
  
  1 O6 16 N4 3.0

Notice the empty lines between the lines. Every restraint group is enclosed by empty lines so here every hydrogen bond is a single group. The first group for example specifies a distance of 3.0 angstroms between N2 of residue 1 and O2 of residue 16. Make sure you have an empty line at the end of the file too.

secondary-structure.dat
----------------------------
This is another plain text file in which there is a character specifying the secondary structure of each residue. random coils are denoted by ``.``, helices are specified by ``H`` and ``E`` corresponds to strands. Since DNA comes first in our topology and we are not restraining it for secondary strures, the first 16 dots in the file represent the DNA and the rest is for protein.
::

  ..................EEEEEE.....EE.HHH....EEE..EEEEEE.................HHHHHHHHHHHHH..
  
You can calculate secondary structures with psipred and modify the output to match the format required by MELD.

protein-DNA-contacts.dat
----------------------------
Here's where you will feed data into MELD. Whatever the source of your data, it will need to be simplified into a set of atom-atom contacts that will be used to specify restraints. Since 1azp is already a solved crystal structure, you can pick a bunch of atoms from protein and DNA that are interacting at the interface. Here I used ``O5'`` and ``CB`` which are parts of the backbone of the protein and DNA, respectively. Here's the first five lines the file:
::

  22  CB 14 P 8.0
  
  22  CB 15 P 8.0
  
  22  CB 16 P 8.0

Note that here we put a distance of 8.0 for all pairs. Down the way we have the option to use this number or specify another desired distance that should be satisfied.

protein-contacts.dat
----------------------------

Since we are not interested in denaturing the protein at high temperature, we need to keep it's tertiary structure with some room for flexibility. We use the python script ``calculate-protein-contacts.py`` to find the backbone ``CAs`` that are in proximity of each other and apply restraints on their pairwise distances to keep the conformation as it is.

starting-structure.pdb
----------------------------

The PDB file from which REMD will start. It is best to minimize this structure (using Amber, Gromacs, NAMD, etc.) before giving it to MELD. Also I have separated the protein from the DNA to prevent it from being trapped in a pose that we know is already favored in the first place.

restraints.py
----------------------------

A set of functions to define restraints based on files specified in setupMELD.py. We generally don't need to modify this file. It has been part of setupMELD.py which is now taken into a new file for simplicity.

setupMELD.py
----------------------------

This is the main file that will prepare the simulation setup for OpenMM. All other files mentioned abolve will be used in setupMELD.py

First things first, import the necessary modules:

.. code-block:: python

    import numpy as np
    from meld.remd import ladder, adaptor, leader
    from meld import comm, vault
    from meld import system
    from meld import parse
    from meld.system.restraints import LinearRamp,ConstantRamp
    import glob
    from restraints import *
    

Next up, specify number of replicas, number of steps and how often to save data into file:
Here we are running 30 replicas, each for 20000 steps and we are saving data every 100 steps.

.. code-block:: python

    N_REPLICAS = 30
    N_STEPS = 20000
    BLOCK_SIZE = 100

We can start one meld simulation from N initial structures (where N <= ``N_REPLICAS``). If there is one initial structure, it will be replicated for each replica. If there is more, they will be copied if necessary to reach ``N_REPLICAS``.
Defining states based on each input template is done as follows:

.. code-block:: python

    def gen_state_templates(index, templates):
        n_templates = len(templates)
        a = system.ProteinMoleculeFromPdbFile(templates[index%n_templates])
        b = system.SystemBuilder(forcefield="ff14sbside")
        c = b.build_system_from_molecules([a])
        pos = c._coordinates
        vel = np.zeros_like(pos)
        alpha = index / (N_REPLICAS - 1.0)
        energy = 0
        return system.SystemState(pos, vel, alpha, energy,[999,999,999] )
        
Finally the ``setup_system`` function will define the simulation setup based input states and restraint data:

.. code-block:: python

    def setup_system():
        templates = glob.glob('TEMPLATES/*.pdb')
        p = system.ProteinMoleculeFromPdbFile(templates[0])
        b = system.SystemBuilder(forcefield="ff14sbside")
        s = b.build_system_from_molecules([p])

**All of the following sections are part of the ``setup_system`` function.**

Define a temprature range and alpha range at which the temperature is applied. Here we want the temprature to scale from 300K to 500K from alpha = 0 to alpha 0.5 which correspond to the first half of replicas:

.. code-block:: python

        s.temperature_scaler = system.GeometricTemperatureScaler(0.0, 0.5, 300., 500.)

define a constant force scaler to restrain protein C alpha distances based on ``protein-contacts.dat``:
``protein_scaler`` is a force with fixed force constant that and ``protein_contacts`` is a collection of restraints.
Notice that when adding this collection of restraints, we are providing ``int(len(protein_contacts)*0.9)`` as a second arguement since we wand meld to satisfy only 90% of this data. i.e. we are allowing 10 of protein contacts to be disconnected at a time.

.. code-block:: python

        protein_scaler = s.restraints.create_scaler('constant')
        protein_contacts = keep_fixed_distance('protein-contacts.dat',s,scaler=protein_scaler)
        s.restraints.add_selectively_active_collection(protein_contacts,int(len(protein_contacts)*0.9))

At this point Meld will generate the ``hbondsDNA.dat`` file based on ``sequence.dat`` and the input structure. Then the baseparing contacts are added as restraints in a similar fashion to protein contacts. Unlike ``protein_scaler``, the ``hbond_scaler`` is not a constant force and is only active at alpha 0.9 to 1.0 to ensure the DNA doesn't melt at high replicas.

.. code-block:: python

        sequenceDNA = readSeq('DNA-sequence.dat')
        make_hbond_restraint_file(sequenceDNA,0)
        hbonds_scaler = s.restraints.create_scaler('nonlinear', alpha_min=0.9, alpha_max=1.0, factor=4.0)
        hbonds = keep_fixed_distance('hbondsDNA.dat',s,scaler=hbonds_scaler)
        s.restraints.add_selectively_active_collection(hbonds_scaler,int(len(hbonds_scaler)*0.9))
        
In addition to base pairing, we can also restraint the DNA in its cartesian coordinates to keep its conformation near-natinve and facilitate binding. Here, any atom with a name from ``atoms`` will be restrained to its starting coordinates. We can use the same fixed force from ``protein_scaler``.

.. code-block:: python

        DNA_positions = make_cartesian_collections(s, protein_scaler, range(1,16),atoms=["C1'","C2","C2'","C3'","C4","C4'","C5","C5'","C6","C7","C8","DA3","N1","N2","N3","N4","N6","N7","N9","O2","O3'","O4","O4'","O5'","O6","OP1","OP2","P"])
        s.restraints.add_as_always_active_list(DNA_positions)

We are also not very interested in drastic changes to the secondary structure of the protein so we will use ``secondary-structure.dat`` to keep it as it is.

.. code-block:: python

        ss_scaler = s.restraints.create_scaler('constant')
        ss_rests = parse.get_secondary_structure_restraints(filename='secondary-structure.dat', system=s,ramp=LinearRamp(0,100,0,1), scaler=ss_scaler,
                torsion_force_constant=2.5, distance_force_constant=2.5)
        s.restraints.add_selectively_active_collection(ss_rests, int(len(ss_rests) * 0.96))

Finally apply restraints based on the contacts between protein and DNA. In this protocol we will guide all the ``CB`` atoms of the protein towards the ``P`` atoms of the DNA with a center of mass restraints. The distance restraint is set to 5nm at alpha 0.7 and scales to 7nm at alpha 1.0. Note that since not every residue has a ``CB`` atom, we exclude those that don't.

.. code-block:: python

        names  = np.array(s.atom_names)
        resid = np.array(s.residue_numbers)    
        select = names == 'CB'
        cb_resids = resid[select]

        conf_rest = []
        group1 = []
        group2 = []
        for i in range(2,9):
            group1.append( (i,"P") )
        for i in range(10,17):
            group1.append( (i,"P") )
        for j in cb_resids:
            group2.append( (j,"CB") )
        protein_DNA_scaler = s.restraints.create_scaler('nonlinear',alpha_min=0.7,alpha_max=1.0, factor=4.0, strength_at_alpha_min=1.0, strength_at_alpha_max=0.5)
        positioner = s.restraints.create_scaler('linear_positioner',alpha_min=0.7, alpha_max=1.0, pos_min=5., pos_max=7.) 
        conf_rest.append(s.restraints.create_restraint('com', protein_DNA_scaler,ramp=LinearRamp(0,100,0,1), 
                                                           force_const=75.0,group1=group1,group2=group2,
                                                           distance =positioner,weights1=None, weights2=None, dims='xyz'))
        s.restraints.add_as_always_active_list(conf_rest)

lastly, some run options need to be specified which usually don't need modification. These include implicit solvent model (``gbNeck2`` here) and time step of 4fs enabled by hydrogen mass repartitioning.

.. code-block:: python

        options = system.RunOptions()
        options.implicit_solvent_model = 'gbNeck2'
        options.remove_com = False
        options.use_big_timestep = False # MD timestep (3.3 fs)
        options.use_bigger_timestep = True # MD timestep (4.0 fs)
        options.cutoff = 1.8 # cutoff in nm
        options.soluteDielectric = 1.
        options.use_amap = False # correction to FF12SB
        options.amap_beta_bias = 1.0
        options.timesteps = 11111 # number of MD steps per exchange
        options.minimize_steps = 20000 # init minimization steps
        
        store = vault.DataStore(s.n_atoms, N_REPLICAS, s.get_pdb_writer(), block_size=BLOCK_SIZE)
        store.initialize(mode='w')
        store.save_system(s)
        store.save_run_options(options)
        l = ladder.NearestNeighborLadder(n_trials=48)
        policy = adaptor.AdaptationPolicy(2.0, 50, 50)
        a = adaptor.EqualAcceptanceAdaptor(n_replicas=N_REPLICAS, adaptation_policy=policy)
        remd_runner = leader.LeaderReplicaExchangeRunner(N_REPLICAS, max_steps=N_STEPS, ladder=l, adaptor=a)
        store.save_remd_runner(remd_runner)
        c = comm.MPICommunicator(s.n_atoms, N_REPLICAS)
        store.save_communicator(c)
        states = [gen_state_templates(i,templates) for i in range(N_REPLICAS)]
        store.save_states(states, 0)
        store.save_data_store()
        return s.n_atoms
        
Calling the ``setup_system`` function will run all the code above.

.. code-block:: python

        setup_system()

It is time to run the ``setupMELD.py`` script from terminal with meld loaded and ready to go:

.. code-block:: bash

        python setupMELD.py
        
The script should excecute with no issues and it will generate a new ``Data`` directory.
To run the meld job you can use:

.. code-block:: bash

        if [ -e remd.log ]; then       #If there is a remd.log we are conitnuing a killed simulation
          prepare_restart --prepare-run #so we need to prepare_restart
            fi
        srun --mpi=pmix_v3 launch_remd --debug
        
This run can take up to two days to conclude on 30 RTX 2080ti GPUs.
Once done, you can extract the trajectory of any replica with a command similar to the following:

.. code-block:: bash

        extract_trajectory extract_traj_dcd --replica 00 trajectory.00.dcd

You can also get the last frame of each replica directly without extracting trajectories:

.. code-block:: bash

        extract_trajectory extract_last last
        
Another thing to control is if you have enough exchange of the replicas to ensure that no replica is trapped in constant conditions.

.. code-block:: bash

        analyze_remd visualize_trace

        
